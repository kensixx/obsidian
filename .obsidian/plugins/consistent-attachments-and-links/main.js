/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ConsistentAttachmentsAndLinksPlugin
});
module.exports = __toCommonJS(main_exports);

// src/ConsistentAttachmentsAndLinksPlugin.ts
var import_obsidian6 = require("obsidian");

// src/links-handler.ts
var import_obsidian3 = require("obsidian");

// src/utils.ts
var Utils = class {
  static normalizePathForFile(path2) {
    path2 = path2.replace(/\\/gi, "/");
    path2 = path2.replace(/%20/gi, " ");
    return path2;
  }
  static normalizePathForLink(path2) {
    path2 = path2.replace(/\\/gi, "/");
    path2 = path2.replace(/ /gi, "%20");
    return path2;
  }
  static normalizeLinkSection(section) {
    section = decodeURI(section);
    return section;
  }
};

// src/path.ts
var path = class {
  static parse(path2) {
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0) {
      return ret;
    }
    let code = path2.charCodeAt(0);
    const isAbsolute = code === 47;
    let start;
    if (isAbsolute) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) {
          ret.base = ret.name = path2.slice(1, end);
        } else {
          ret.base = ret.name = path2.slice(startPart, end);
        }
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    if (startPart > 0) {
      ret.dir = path2.slice(0, startPart - 1);
    } else if (isAbsolute) {
      ret.dir = "/";
    }
    return ret;
  }
  static posixNormalize(path2) {
    if (path2.length === 0) {
      return ".";
    }
    const isAbsolute = path2.charCodeAt(0) === 47;
    const trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = this.normalizeStringPosix(path2, !isAbsolute);
    if (path2.length === 0 && !isAbsolute) {
      path2 = ".";
    }
    if (path2.length > 0 && trailingSeparator) {
      path2 += "/";
    }
    if (isAbsolute) {
      return "/" + path2;
    }
    return path2;
  }
  static normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for (let i = 0; i <= path2.length; ++i) {
      if (i < path2.length) {
        code = path2.charCodeAt(i);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += "/" + path2.slice(lastSlash + 1, i);
          } else {
            res = path2.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  static posixResolve(...args) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      let path2 = "";
      if (i >= 0) {
        path2 = args[i];
      } else {
        if (cwd === void 0) {
          cwd = process.cwd();
        }
        path2 = cwd;
      }
      if (path2.length === 0) {
        continue;
      }
      resolvedPath = path2 + "/" + resolvedPath;
      resolvedAbsolute = path2.charCodeAt(0) === 47;
    }
    resolvedPath = this.normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) {
        return "/" + resolvedPath;
      } else {
        return "/";
      }
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return ".";
    }
  }
  static relative(from, to) {
    if (from === to) {
      return "";
    }
    from = this.posixResolve(from);
    to = this.posixResolve(to);
    if (from === to) {
      return "";
    }
    let fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  }
};

// src/links-handler.ts
var import_posix = require("node:path/posix");

// src/Error.ts
var import_obsidian = require("obsidian");
function showError(error) {
  console.error(error);
  new import_obsidian.Notice("An unhandled error occurred. Please check the console for more information.");
}

// src/Async.ts
async function retryWithTimeout(asyncFn, {
  timeoutInMilliseconds = 5e3,
  retryDelayInMilliseconds = 100
} = {}) {
  await runWithTimeout(timeoutInMilliseconds, async () => {
    let failedBefore = false;
    while (true) {
      if (await asyncFn()) {
        if (failedBefore) {
          console.debug("Retry completed successfully");
        }
        return;
      }
      failedBefore = true;
      console.debug(`Retry completed unsuccessfully. Trying again in ${retryDelayInMilliseconds} milliseconds`);
      await sleep(retryDelayInMilliseconds);
    }
  });
}
async function runWithTimeout(timeoutInMilliseconds, asyncFn) {
  return await Promise.race([asyncFn(), timeout()]);
  async function timeout() {
    await sleep(timeoutInMilliseconds);
    throw new Error(`Timed out in ${timeoutInMilliseconds} milliseconds`);
  }
}
function convertToSync(promise) {
  promise.catch(showError);
}

// src/MetadataCache.ts
async function getCacheSafe(app, fileOrPath) {
  const file = typeof fileOrPath === "string" ? app.vault.getFileByPath(fileOrPath) : fileOrPath;
  if (!file) {
    throw new Error(`File ${fileOrPath} not found`);
  }
  let cache = null;
  await retryWithTimeout(async () => {
    const fileInfo = app.metadataCache.getFileInfo(file.path);
    const stat = await app.vault.adapter.stat(file.path);
    if (!fileInfo) {
      console.debug(`File cache info for ${file.path} is missing`);
      return false;
    } else if (!stat) {
      console.debug(`File stat for ${file.path} is missing`);
      return false;
    } else if (fileInfo.mtime < stat.mtime) {
      console.debug(`File cache info for ${file.path} is from ${new Date(fileInfo.mtime).toString()} which is older than the file modification timestamp ${new Date(stat.mtime).toString()}`);
      return false;
    } else {
      cache = app.metadataCache.getFileCache(file);
      if (!cache) {
        console.debug(`File cache for ${file.path} is missing`);
        return false;
      } else {
        return true;
      }
    }
  }, {
    timeoutInMilliseconds: 3e4
  });
  return cache;
}
function getAllLinks(cache) {
  let links = [];
  if (cache.links) {
    links.push(...cache.links);
  }
  if (cache.embeds) {
    links.push(...cache.embeds);
  }
  links.sort((a, b) => a.position.start.offset - b.position.start.offset);
  links = links.filter((link, index) => {
    if (index === 0) {
      return true;
    }
    return link.position.start.offset !== links[index - 1].position.start.offset;
  });
  return links;
}

// src/Vault.ts
var import_obsidian2 = require("obsidian");

// src/Object.ts
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== "object" || typeof b !== "object" || a === null || b === null || a === void 0 || b === void 0) {
    return false;
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const aRecord = a;
  const bRecord = b;
  for (const key of keysA) {
    if (!keysB.includes(key) || !deepEqual(aRecord[key], bRecord[key])) {
      return false;
    }
  }
  return true;
}
function toJson(value) {
  return JSON.stringify(value, null, 2);
}

// src/Vault.ts
function getMarkdownFilesSorted(app) {
  return app.vault.getMarkdownFiles().sort((a, b) => a.path.localeCompare(b.path));
}
async function processWithRetry(app, file, processFn) {
  await retryWithTimeout(async () => {
    const oldContent = await app.vault.read(file);
    const newContent = await processFn(oldContent);
    let success = true;
    await app.vault.process(file, (content) => {
      if (content !== oldContent) {
        console.warn(`Content of ${file.path} has changed since it was read. Retrying...`);
        success = false;
        return content;
      }
      return newContent;
    });
    return success;
  });
}
async function applyFileChanges(app, file, changesFn) {
  await processWithRetry(app, file, async (content) => {
    let changes = await changesFn();
    changes.sort((a, b) => a.startIndex - b.startIndex);
    changes = changes.filter((change, index) => {
      if (index === 0) {
        return true;
      }
      return !deepEqual(change, changes[index - 1]);
    });
    for (let i = 1; i < changes.length; i++) {
      if (changes[i - 1].endIndex >= changes[i].startIndex) {
        throw new Error(`Overlapping changes:
${toJson(changes[i - 1])}
${toJson(changes[i])}`);
      }
    }
    let newContent = "";
    let lastIndex = 0;
    for (const change of changes) {
      newContent += content.slice(lastIndex, change.startIndex);
      newContent += change.newContent;
      lastIndex = change.endIndex;
    }
    newContent += content.slice(lastIndex);
    return newContent;
  });
}

// src/links-handler.ts
var ConsistencyCheckResult = class extends Map {
  constructor(title) {
    super();
    this.title = title;
  }
  add(notePath, link) {
    if (!this.has(notePath)) {
      this.set(notePath, []);
    }
    this.get(notePath).push(link);
  }
  toString() {
    if (this.size > 0) {
      let str = `# ${this.title} (${this.size} files)
`;
      for (const notePath of this.keys()) {
        str += `[${notePath}](${Utils.normalizePathForLink(notePath)}):
`;
        for (const link of this.get(notePath)) {
          str += `- (line ${link.position.start.line + 1}): \`${link.link}\`
`;
        }
        str += "\n\n";
      }
      return str;
    } else {
      return `# ${this.title}
No problems found

`;
    }
  }
};
var markdownLinkOrEmbedRegexG = /(?<!\\)\[(.*?)(?<!\\)\]\((.*?)(?<!\\)\)/gim;
var markdownLinkRegexG = /(?<!\!)(?<!\\)\[(.*?)(?<!\\)\]\((.*?)(?<!\\)(?:#(.*?))?\)/gim;
var markdownEmbedRegexG = /(?<!\\)\!\[(.*?)(?<!\\)\]\((.*?)(?<!\\)\)/gim;
var wikiLinkOrEmbedRegexG = /(?<!\\)\[\[(.*?)(?<!\\)\]\]/gim;
var wikiLinkRegexG = /(?<!\!)(?<!\\)\[\[(.*?)(?<!\\)\]\]/gim;
var wikiEmbedRegexG = /(?<!\\)\!\[\[(.*?)(?<!\\)\]\]/gim;
var markdownLinkOrEmbedRegex = /(?<!\\)\[(.*?)(?<!\\)\]\((.*?)(?<!\\)\)/im;
var markdownLinkRegex = /(?<!\!)(?<!\\)\[(.*?)(?<!\\)\]\((.*?)(?<!\\)\)/im;
var LinksHandler = class {
  constructor(app, consoleLogPrefix = "", ignoreFolders = [], ignoreFilesRegex = []) {
    this.app = app;
    this.consoleLogPrefix = consoleLogPrefix;
    this.ignoreFolders = ignoreFolders;
    this.ignoreFilesRegex = ignoreFilesRegex;
  }
  isPathIgnored(path2) {
    if (path2.startsWith("./")) {
      path2 = path2.substring(2);
    }
    for (const folder of this.ignoreFolders) {
      if (path2.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this.ignoreFilesRegex) {
      if (fileRegex.test(path2)) {
        return true;
      }
    }
    return false;
  }
  checkIsCorrectMarkdownEmbed(text) {
    const elements = text.match(markdownEmbedRegexG);
    return elements != null && elements.length > 0;
  }
  checkIsCorrectMarkdownLink(text) {
    const elements = text.match(markdownLinkRegexG);
    return elements != null && elements.length > 0;
  }
  checkIsCorrectMarkdownEmbedOrLink(text) {
    const elements = text.match(markdownLinkOrEmbedRegexG);
    return elements != null && elements.length > 0;
  }
  checkIsCorrectWikiEmbed(text) {
    const elements = text.match(wikiEmbedRegexG);
    return elements != null && elements.length > 0;
  }
  checkIsCorrectWikiLink(text) {
    const elements = text.match(wikiLinkRegexG);
    return elements != null && elements.length > 0;
  }
  checkIsCorrectWikiEmbedOrLink(text) {
    const elements = text.match(wikiLinkOrEmbedRegexG);
    return elements != null && elements.length > 0;
  }
  getFileByLink(link, owningNotePath, allowInvalidLink = true) {
    [link] = this.splitSubpath(link);
    if (allowInvalidLink) {
      return this.app.metadataCache.getFirstLinkpathDest(link, owningNotePath);
    }
    const fullPath = this.getFullPathForLink(link, owningNotePath);
    return this.app.vault.getFileByPath(fullPath);
  }
  getFullPathForLink(link, owningNotePath) {
    [link] = this.splitSubpath(link);
    link = Utils.normalizePathForFile(link);
    owningNotePath = Utils.normalizePathForFile(owningNotePath);
    const parentFolder = owningNotePath.substring(0, owningNotePath.lastIndexOf("/"));
    let fullPath = (0, import_posix.join)(parentFolder, link);
    fullPath = Utils.normalizePathForFile(fullPath);
    return fullPath;
  }
  async getAllCachedLinksToFile(filePath) {
    const allLinks = {};
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian3.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Getting all cached links to file ${filePath} # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (note.path == filePath) {
        continue;
      }
      const links = (await getCacheSafe(this.app, note.path)).links ?? [];
      for (const link of links) {
        const linkFullPath = this.getFullPathForLink(link.link, note.path);
        if (linkFullPath == filePath) {
          this.addToRecord(allLinks, note.path, link);
        }
      }
    }
    notice.hide();
    return allLinks;
  }
  addToRecord(record, path2, value) {
    if (!record[path2]) {
      record[path2] = [];
    }
    record[path2].push(value);
  }
  async getAllCachedEmbedsToFile(filePath) {
    const allEmbeds = {};
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian3.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Getting all cached embeds to file ${filePath} # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (note.path == filePath) {
        continue;
      }
      const embeds = (await getCacheSafe(this.app, note.path)).embeds ?? [];
      for (const embed of embeds) {
        const linkFullPath = this.getFullPathForLink(embed.link, note.path);
        if (linkFullPath == filePath) {
          this.addToRecord(allEmbeds, note.path, embed);
        }
      }
    }
    notice.hide();
    return allEmbeds;
  }
  async isValidLink(link, notePath) {
    const [linkPath, subpath] = this.splitSubpath(link.link);
    let fullLinkPath;
    if (!linkPath) {
      fullLinkPath = notePath;
    } else if (linkPath.startsWith("/")) {
      fullLinkPath = (0, import_obsidian3.normalizePath)(linkPath);
    } else {
      fullLinkPath = (0, import_posix.join)((0, import_posix.dirname)(notePath), linkPath);
    }
    const file = this.app.vault.getFileByPath(fullLinkPath);
    if (!file) {
      return false;
    }
    if (!subpath) {
      return true;
    }
    const ext = file.extension.toLocaleLowerCase();
    if (ext === "pdf") {
      return subpath.startsWith("#page=");
    }
    if (ext !== "md") {
      return false;
    }
    const cache = await getCacheSafe(this.app, file);
    if (subpath.startsWith("#^")) {
      return Object.keys(cache.blocks ?? {}).includes(subpath.slice(2));
    } else {
      return (cache.headings ?? []).map((h) => h.heading.replaceAll("#", " ")).includes(subpath.slice(1));
    }
  }
  async getAllGoodLinks() {
    const allLinks = {};
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian3.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Getting good links # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const links = (await getCacheSafe(this.app, note.path)).links ?? [];
      for (const link of links) {
        if (link.link.startsWith("#")) {
          continue;
        }
        if (this.checkIsCorrectWikiLink(link.original)) {
          continue;
        }
        const file = this.getFileByLink(link.link, note.path);
        if (file) {
          this.addToRecord(allLinks, note.path, link);
        }
      }
    }
    notice.hide();
    return allLinks;
  }
  async getAllGoodEmbeds() {
    const allEmbeds = {};
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian3.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Getting good embeds # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const embeds = (await getCacheSafe(this.app, note.path)).embeds ?? [];
      for (const embed of embeds) {
        if (this.checkIsCorrectWikiEmbed(embed.original)) {
          continue;
        }
        const file = this.getFileByLink(embed.link, note.path);
        if (file) {
          this.addToRecord(allEmbeds, note.path, embed);
        }
      }
    }
    notice.hide();
    return allEmbeds;
  }
  async updateLinksToRenamedFile(oldNotePath, newNotePath, changeLinksAlt = false) {
    if (this.isPathIgnored(oldNotePath) || this.isPathIgnored(newNotePath)) {
      return;
    }
    const notes = this.getCachedNotesThatHaveLinkToFile(oldNotePath);
    const links = [{ oldPath: oldNotePath, newPath: newNotePath }];
    if (notes) {
      for (const note of notes) {
        await this.updateChangedPathsInNote(note, links, changeLinksAlt);
      }
    }
  }
  async updateChangedPathInNote(notePath, oldLink, newLink, changeLinksAlt = false) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    const changes = [{ oldPath: oldLink, newPath: newLink }];
    return await this.updateChangedPathsInNote(notePath, changes, changeLinksAlt);
  }
  async updateChangedPathsInNote(notePath, changedLinks, changeLinksAlt = false) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    const note = this.app.vault.getFileByPath(notePath);
    if (!note) {
      showError(this.consoleLogPrefix + "cant update links in note, file not found: " + notePath);
      return;
    }
    const pathChangeMap = /* @__PURE__ */ new Map();
    for (const change of changedLinks) {
      pathChangeMap.set(change.oldPath, change.newPath);
    }
    await applyFileChanges(this.app, note, async () => {
      const cache = await getCacheSafe(this.app, note);
      const links = getAllLinks(cache);
      return links.map((link) => ({
        startIndex: link.position.start.offset,
        endIndex: link.position.end.offset,
        newContent: this.convertLink(note, link, note.path, pathChangeMap, changeLinksAlt)
      }));
    });
  }
  convertLink(note, link, oldNotePath, pathChangeMap, changeLinksAlt) {
    const [linkPath = "", subpath] = this.splitSubpath(link.link);
    const oldLinkPath = (0, import_posix.join)((0, import_posix.dirname)(oldNotePath), linkPath);
    const newLinkPath = pathChangeMap ? pathChangeMap.get(oldLinkPath) : (0, import_posix.join)((0, import_posix.dirname)(note.path), linkPath);
    if (!newLinkPath) {
      return link.original;
    }
    const newLinkedNote = this.app.vault.getFileByPath(oldLinkPath) ?? this.app.vault.getFileByPath(newLinkPath);
    if (!newLinkedNote) {
      return link.original;
    }
    return this.app.fileManager.generateMarkdownLink(newLinkedNote, note.path, subpath, changeLinksAlt === false ? link.displayText : void 0);
  }
  splitSubpath(link) {
    const SUBPATH_SEPARATOR = "#";
    const [linkPath = "", subpath] = link.split(SUBPATH_SEPARATOR);
    return [linkPath, subpath ? SUBPATH_SEPARATOR + subpath : void 0];
  }
  async updateInternalLinksInMovedNote(oldNotePath, newNotePath) {
    if (this.isPathIgnored(oldNotePath) || this.isPathIgnored(newNotePath)) {
      return;
    }
    const newNote = this.app.vault.getFileByPath(newNotePath);
    if (!newNote) {
      showError(this.consoleLogPrefix + "can't update internal links, file not found: " + newNotePath);
      return;
    }
    await applyFileChanges(this.app, newNote, async () => {
      const cache = await getCacheSafe(this.app, newNote);
      const links = getAllLinks(cache);
      return links.map((link) => ({
        startIndex: link.position.start.offset,
        endIndex: link.position.end.offset,
        newContent: this.convertLink(newNote, link, oldNotePath)
      }));
    });
  }
  getCachedNotesThatHaveLinkToFile(filePath) {
    const file = this.app.vault.getFileByPath(filePath);
    if (!file) {
      return [];
    }
    const backlinks = this.app.metadataCache.getBacklinksForFile(file);
    return backlinks.keys();
  }
  getFilePathWithRenamedBaseName(filePath, newBaseName) {
    return Utils.normalizePathForFile((0, import_posix.join)((0, import_posix.dirname)(filePath), newBaseName + (0, import_posix.extname)(filePath)));
  }
  async getLinksFromNote(notePath) {
    const file = this.app.vault.getFileByPath(notePath);
    if (!file) {
      showError(this.consoleLogPrefix + "can't get embeds, file not found: " + notePath);
      return [];
    }
    const text = await this.app.vault.read(file);
    const links = [];
    const elements = text.match(markdownLinkOrEmbedRegexG);
    if (elements != null && elements.length > 0) {
      for (const el of elements) {
        const alt = el.match(markdownLinkOrEmbedRegex)[1];
        const link = el.match(markdownLinkOrEmbedRegex)[2];
        const emb = {
          link,
          displayText: alt,
          original: el,
          position: {
            start: {
              col: 0,
              //todo
              line: 0,
              offset: 0
            },
            end: {
              col: 0,
              //todo
              line: 0,
              offset: 0
            }
          }
        };
        links.push(emb);
      }
    }
    return links;
  }
  async convertAllNoteEmbedsPathsToRelative(notePath) {
    if (this.isPathIgnored(notePath)) {
      return [];
    }
    const changedEmbeds = [];
    const embeds = (await getCacheSafe(this.app, notePath)).embeds ?? [];
    for (const embed of embeds) {
      const isMarkdownEmbed = this.checkIsCorrectMarkdownEmbed(embed.original);
      const isWikiEmbed = this.checkIsCorrectWikiEmbed(embed.original);
      if (isMarkdownEmbed || isWikiEmbed) {
        let file = this.getFileByLink(embed.link, notePath);
        if (file) {
          continue;
        }
        file = this.app.metadataCache.getFirstLinkpathDest(embed.link, notePath);
        if (file) {
          let newRelLink = path.relative(notePath, file.path);
          newRelLink = isMarkdownEmbed ? Utils.normalizePathForLink(newRelLink) : Utils.normalizePathForFile(newRelLink);
          if (newRelLink.startsWith("../")) {
            newRelLink = newRelLink.substring(3);
          }
          changedEmbeds.push({ old: embed, newLink: newRelLink });
        } else {
          showError(this.consoleLogPrefix + notePath + " has bad embed (file does not exist): " + embed.link);
        }
      } else {
        showError(this.consoleLogPrefix + notePath + " has bad embed (format of link is not markdown or wiki link): " + embed.original);
      }
    }
    await this.updateChangedEmbedInNote(notePath, changedEmbeds);
    return changedEmbeds;
  }
  async convertAllNoteLinksPathsToRelative(notePath) {
    if (this.isPathIgnored(notePath)) {
      return [];
    }
    const changedLinks = [];
    const links = (await getCacheSafe(this.app, notePath)).links ?? [];
    for (const link of links) {
      const isMarkdownLink = this.checkIsCorrectMarkdownLink(link.original);
      const isWikiLink = this.checkIsCorrectWikiLink(link.original);
      if (isMarkdownLink || isWikiLink) {
        if (link.link.startsWith("#")) {
          continue;
        }
        let file = this.getFileByLink(link.link, notePath);
        if (file) {
          continue;
        }
        if (isMarkdownLink) {
          const elements = link.original.match(markdownLinkRegex);
          if (elements) {
            link.displayText = elements[1];
          }
        }
        file = this.app.metadataCache.getFirstLinkpathDest(link.link, notePath);
        if (file) {
          let newRelLink = path.relative(notePath, file.path);
          newRelLink = isMarkdownLink ? Utils.normalizePathForLink(newRelLink) : Utils.normalizePathForFile(newRelLink);
          if (newRelLink.startsWith("../")) {
            newRelLink = newRelLink.substring(3);
          }
          changedLinks.push({ old: link, newLink: newRelLink });
        } else {
          showError(this.consoleLogPrefix + notePath + " has bad link (file does not exist): " + link.link);
        }
      } else {
        showError(this.consoleLogPrefix + notePath + " has bad link (format of link is not markdown or wiki link): " + link.original);
      }
    }
    await this.updateChangedLinkInNote(notePath, changedLinks);
    return changedLinks;
  }
  async updateChangedEmbedInNote(notePath, changedEmbeds) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    const noteFile = this.app.vault.getFileByPath(notePath);
    if (!noteFile) {
      showError(this.consoleLogPrefix + "can't update embeds in note, file not found: " + notePath);
      return;
    }
    let text = await this.app.vault.read(noteFile);
    let dirty = false;
    if (changedEmbeds && changedEmbeds.length > 0) {
      for (const embed of changedEmbeds) {
        if (embed.old.link == embed.newLink) {
          continue;
        }
        if (this.checkIsCorrectMarkdownEmbed(embed.old.original)) {
          text = text.replace(embed.old.original, "![" + embed.old.displayText + "](" + embed.newLink + ")");
        } else if (this.checkIsCorrectWikiEmbed(embed.old.original)) {
          text = text.replace(embed.old.original, "![[" + embed.newLink + "]]");
        } else {
          showError(this.consoleLogPrefix + notePath + " has bad embed (format of link is not markdown or wikilink): " + embed.old.original);
          continue;
        }
        console.log(this.consoleLogPrefix + "embed updated in note [note, old link, new link]: \n   " + noteFile.path + "\n   " + embed.old.link + "\n   " + embed.newLink);
        dirty = true;
      }
    }
    if (dirty) {
      await this.app.vault.modify(noteFile, text);
    }
  }
  async updateChangedLinkInNote(notePath, changedLinks) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    const noteFile = this.app.vault.getFileByPath(notePath);
    if (!noteFile) {
      showError(this.consoleLogPrefix + "can't update links in note, file not found: " + notePath);
      return;
    }
    let text = await this.app.vault.read(noteFile);
    let dirty = false;
    if (changedLinks && changedLinks.length > 0) {
      for (const link of changedLinks) {
        if (link.old.link == link.newLink) {
          continue;
        }
        if (this.checkIsCorrectMarkdownLink(link.old.original)) {
          text = text.replace(link.old.original, "[" + link.old.displayText + "](" + link.newLink + ")");
        } else if (this.checkIsCorrectWikiLink(link.old.original)) {
          text = text.replace(link.old.original, "[[" + link.newLink + "]]");
        } else {
          showError(this.consoleLogPrefix + notePath + " has bad link (format of link is not markdown or wikilink): " + link.old.original);
          continue;
        }
        console.log(this.consoleLogPrefix + "cached link updated in note [note, old link, new link]: \n   " + noteFile.path + "\n   " + link.old.link + "\n   " + link.newLink);
        dirty = true;
      }
    }
    if (dirty) {
      await this.app.vault.modify(noteFile, text);
    }
  }
  async replaceAllNoteWikilinksWithMarkdownLinks(notePath) {
    if (this.isPathIgnored(notePath)) {
      return { embeds: [], links: [] };
    }
    const res = {
      links: [],
      embeds: []
    };
    const noteFile = this.app.vault.getFileByPath(notePath);
    if (!noteFile) {
      showError(this.consoleLogPrefix + "can't update wikilinks in note, file not found: " + notePath);
      return { embeds: [], links: [] };
    }
    const cache = await getCacheSafe(this.app, notePath);
    const links = cache.links ?? [];
    const embeds = cache.embeds ?? [];
    let text = await this.app.vault.read(noteFile);
    let dirty = false;
    for (const embed of embeds) {
      if (this.checkIsCorrectWikiEmbed(embed.original)) {
        const newPath = Utils.normalizePathForLink(embed.link);
        const newLink = "![](" + newPath + ")";
        text = text.replace(embed.original, newLink);
        console.log(this.consoleLogPrefix + "wiki link (embed) replaced in note [note, old link, new link]: \n   " + noteFile.path + "\n   " + embed.original + "\n   " + newLink);
        res.embeds.push({ old: embed, newLink });
        dirty = true;
      }
    }
    for (const link of links) {
      if (this.checkIsCorrectWikiLink(link.original)) {
        let newPath = Utils.normalizePathForLink(link.link);
        const file = this.app.metadataCache.getFirstLinkpathDest(link.link, notePath);
        if (file && file.extension == "md" && !newPath.endsWith(".md")) {
          newPath = newPath + ".md";
        }
        const newLink = "[" + link.displayText + "](" + newPath + ")";
        text = text.replace(link.original, newLink);
        console.log(this.consoleLogPrefix + "wiki link replaced in note [note, old link, new link]: \n   " + noteFile.path + "\n   " + link.original + "\n   " + newLink);
        res.links.push({ old: link, newLink });
        dirty = true;
      }
    }
    if (dirty) {
      await this.app.vault.modify(noteFile, text);
    }
    return res;
  }
  async checkConsistency(note, badLinks, badEmbeds, wikiLinks, wikiEmbeds) {
    if (this.isPathIgnored(note.path)) {
      return;
    }
    const cache = await getCacheSafe(this.app, note.path);
    const links = cache.links ?? [];
    const embeds = cache.embeds ?? [];
    for (const link of links) {
      if (!await this.isValidLink(link, note.path)) {
        badLinks.add(note.path, link);
      }
      if (link.original.includes("[[")) {
        wikiLinks.add(note.path, link);
      }
    }
    for (const embed of embeds) {
      if (!await this.isValidLink(embed, note.path)) {
        badEmbeds.add(note.path, embed);
      }
      if (embed.original.includes("[[")) {
        wikiEmbeds.add(note.path, embed);
      }
    }
  }
};

// src/files-handler.ts
var import_obsidian4 = require("obsidian");
var import_posix2 = require("node:path/posix");
var FilesHandler = class {
  constructor(app, lh, consoleLogPrefix = "", ignoreFolders = [], ignoreFilesRegex = []) {
    this.app = app;
    this.lh = lh;
    this.consoleLogPrefix = consoleLogPrefix;
    this.ignoreFolders = ignoreFolders;
    this.ignoreFilesRegex = ignoreFilesRegex;
  }
  isPathIgnored(path2) {
    if (path2.startsWith("./")) {
      path2 = path2.substring(2);
    }
    for (const folder of this.ignoreFolders) {
      if (path2.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this.ignoreFilesRegex) {
      const testResult = fileRegex.test(path2);
      if (testResult) {
        return true;
      }
    }
    return false;
  }
  async createFolderForAttachmentFromLink(link, owningNotePath) {
    const newFullPath = this.lh.getFullPathForLink(link, owningNotePath);
    return await this.createFolderForAttachmentFromPath(newFullPath);
  }
  async createFolderForAttachmentFromPath(filePath) {
    const newParentFolder = filePath.substring(0, filePath.lastIndexOf("/"));
    try {
      await this.app.vault.createFolder(newParentFolder);
    } catch {
    }
  }
  generateFileCopyName(originalName) {
    const ext = (0, import_posix2.extname)(originalName);
    const baseName = (0, import_posix2.basename)(originalName, ext);
    const dir = (0, import_posix2.dirname)(originalName);
    for (let i = 1; i < 1e5; i++) {
      const newName = dir + "/" + baseName + " " + i + ext;
      const existFile = this.app.vault.getFileByPath(newName);
      if (!existFile) {
        return newName;
      }
    }
    return "";
  }
  async moveCachedNoteAttachments(oldNotePath, newNotePath, deleteExistFiles, attachmentsSubfolder, deleteEmptyFolders) {
    if (this.isPathIgnored(oldNotePath) || this.isPathIgnored(newNotePath)) {
      return { movedAttachments: [], renamedFiles: [] };
    }
    const cache = await getCacheSafe(this.app, oldNotePath);
    const links = getAllLinks(cache);
    const result = {
      movedAttachments: [],
      renamedFiles: []
    };
    for (const link of links) {
      const [linkPath] = this.lh.splitSubpath(link.link);
      const oldLinkPath = this.lh.getFullPathForLink(linkPath, oldNotePath);
      if (result.movedAttachments.findIndex((x) => x.oldPath == oldLinkPath) != -1) {
        continue;
      }
      let file = this.lh.getFileByLink(linkPath, oldNotePath);
      if (!file) {
        file = this.lh.getFileByLink(linkPath, newNotePath);
        if (!file) {
          showError(this.consoleLogPrefix + oldNotePath + " has bad embed (file does not exist): " + linkPath);
          continue;
        }
      }
      if ((0, import_posix2.dirname)(oldNotePath) != "." && !(0, import_posix2.dirname)(oldLinkPath).startsWith((0, import_posix2.dirname)(oldNotePath))) {
        continue;
      }
      if (!this.isAttachment(file)) {
        continue;
      }
      const newLinkPath = this.getNewAttachmentPath(file.path, newNotePath, attachmentsSubfolder);
      if (newLinkPath == file.path) {
        continue;
      }
      const res = await this.moveAttachment(file, newLinkPath, [oldNotePath, newNotePath], deleteExistFiles, deleteEmptyFolders);
      result.movedAttachments = result.movedAttachments.concat(res.movedAttachments);
      result.renamedFiles = result.renamedFiles.concat(res.renamedFiles);
    }
    return result;
  }
  getNewAttachmentPath(oldAttachmentPath, notePath, subfolderName) {
    const resolvedSubFolderName = subfolderName.replace(/\${filename}/g, (0, import_posix2.basename)(notePath, ".md"));
    let newPath = resolvedSubFolderName == "" ? (0, import_posix2.dirname)(notePath) : (0, import_posix2.join)((0, import_posix2.dirname)(notePath), resolvedSubFolderName);
    newPath = Utils.normalizePathForFile((0, import_posix2.join)(newPath, (0, import_posix2.basename)(oldAttachmentPath)));
    return newPath;
  }
  async collectAttachmentsForCachedNote(notePath, subfolderName, deleteExistFiles, deleteEmptyFolders) {
    if (this.isPathIgnored(notePath)) {
      return { movedAttachments: [], renamedFiles: [] };
    }
    const result = {
      movedAttachments: [],
      renamedFiles: []
    };
    const cache = await getCacheSafe(this.app, notePath);
    for (const link of getAllLinks(cache)) {
      const [linkPath] = this.lh.splitSubpath(link.link);
      if (!linkPath) {
        continue;
      }
      const fullPathLink = this.lh.getFullPathForLink(linkPath, notePath);
      if (result.movedAttachments.findIndex((x) => x.oldPath == fullPathLink) != -1) {
        continue;
      }
      const file = this.lh.getFileByLink(linkPath, notePath);
      if (!file) {
        const type = link.original.startsWith("!") ? "embed" : "link";
        showError(`${this.consoleLogPrefix}${notePath} has bad ${type} (file does not exist): ${linkPath}`);
        continue;
      }
      if (!this.isAttachment(file)) {
        continue;
      }
      const newPath = this.getNewAttachmentPath(file.path, notePath, subfolderName);
      if (newPath == file.path) {
        continue;
      }
      const res = await this.moveAttachment(file, newPath, [notePath], deleteExistFiles, deleteEmptyFolders);
      result.movedAttachments = result.movedAttachments.concat(res.movedAttachments);
      result.renamedFiles = result.renamedFiles.concat(res.renamedFiles);
    }
    return result;
  }
  async moveAttachment(file, newLinkPath, parentNotePaths, deleteExistFiles, deleteEmptyFolders) {
    const path2 = file.path;
    const result = {
      movedAttachments: [],
      renamedFiles: []
    };
    if (this.isPathIgnored(path2)) {
      return result;
    }
    if (!this.isAttachment(file)) {
      return result;
    }
    if (path2 == newLinkPath) {
      console.warn(this.consoleLogPrefix + "Can't move file. Source and destination path the same.");
      return result;
    }
    await this.createFolderForAttachmentFromPath(newLinkPath);
    const linkedNotes = this.lh.getCachedNotesThatHaveLinkToFile(path2);
    if (parentNotePaths) {
      for (const notePath of parentNotePaths) {
        linkedNotes.remove(notePath);
      }
    }
    if (path2 !== file.path) {
      console.warn(this.consoleLogPrefix + "File was moved already");
      return await this.moveAttachment(file, newLinkPath, parentNotePaths, deleteExistFiles, deleteEmptyFolders);
    }
    if (linkedNotes.length == 0) {
      const existFile = this.app.vault.getFileByPath(newLinkPath);
      if (!existFile) {
        console.log(this.consoleLogPrefix + "move file [from, to]: \n   " + path2 + "\n   " + newLinkPath);
        result.movedAttachments.push({ oldPath: path2, newPath: newLinkPath });
        await this.app.vault.rename(file, newLinkPath);
      } else {
        if (deleteExistFiles) {
          console.log(this.consoleLogPrefix + "delete file: \n   " + path2);
          result.movedAttachments.push({ oldPath: path2, newPath: newLinkPath });
          await this.deleteFile(file, deleteEmptyFolders);
        } else {
          const newFileCopyName = this.generateFileCopyName(newLinkPath);
          console.log(this.consoleLogPrefix + "copy file with new name [from, to]: \n   " + path2 + "\n   " + newFileCopyName);
          result.movedAttachments.push({ oldPath: path2, newPath: newFileCopyName });
          await this.app.vault.rename(file, newFileCopyName);
          result.renamedFiles.push({ oldPath: newLinkPath, newPath: newFileCopyName });
        }
      }
    } else {
      const existFile = this.app.vault.getFileByPath(newLinkPath);
      if (!existFile) {
        console.log(this.consoleLogPrefix + "copy file [from, to]: \n   " + path2 + "\n   " + newLinkPath);
        result.movedAttachments.push({ oldPath: path2, newPath: newLinkPath });
        await this.app.vault.copy(file, newLinkPath);
      } else {
        if (deleteExistFiles) {
        } else {
          const newFileCopyName = this.generateFileCopyName(newLinkPath);
          console.log(this.consoleLogPrefix + "copy file with new name [from, to]: \n   " + path2 + "\n   " + newFileCopyName);
          result.movedAttachments.push({ oldPath: file.path, newPath: newFileCopyName });
          await this.app.vault.copy(file, newFileCopyName);
          result.renamedFiles.push({ oldPath: newLinkPath, newPath: newFileCopyName });
        }
      }
    }
    return result;
  }
  async deleteEmptyFolders(dirName) {
    if (this.isPathIgnored(dirName)) {
      return;
    }
    if (dirName.startsWith("./")) {
      dirName = dirName.substring(2);
    }
    let list = await this.safeList(dirName);
    for (const folder of list.folders) {
      await this.deleteEmptyFolders(folder);
    }
    list = await this.safeList(dirName);
    if (list.files.length == 0 && list.folders.length == 0) {
      console.log(this.consoleLogPrefix + "delete empty folder: \n   " + dirName);
      if (await this.app.vault.adapter.exists(dirName)) {
        try {
          await this.app.vault.adapter.rmdir(dirName, false);
        } catch (e) {
          if (await this.app.vault.adapter.exists(dirName)) {
            throw e;
          }
        }
      }
    }
  }
  async deleteUnusedAttachmentsForCachedNote(notePath, cache, deleteEmptyFolders) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    for (const link of getAllLinks(cache)) {
      const [linkPath] = this.lh.splitSubpath(link.link);
      const file = this.lh.getFileByLink(linkPath, notePath, false);
      if (!file || !this.isAttachment(file)) {
        continue;
      }
      const linkedNotes = this.lh.getCachedNotesThatHaveLinkToFile(file.path);
      if (linkedNotes.length == 0) {
        try {
          await this.deleteFile(file, deleteEmptyFolders);
        } catch {
        }
      }
    }
  }
  async deleteFile(file, deleteEmptyFolders) {
    await this.app.vault.trash(file, true);
    if (deleteEmptyFolders) {
      let dir = file.parent;
      while (dir.children.length === 0) {
        await this.app.vault.trash(dir, true);
        dir = dir.parent;
      }
    }
  }
  isAttachment(file) {
    const extension = file.extension.toLowerCase();
    return extension !== "md" && extension !== "canvas";
  }
  async safeList(path2) {
    const EMPTY = { files: [], folders: [] };
    if (!await this.app.vault.adapter.exists(path2)) {
      return EMPTY;
    }
    try {
      return await this.app.vault.adapter.list(path2);
    } catch (e) {
      if (await this.app.vault.adapter.exists(path2)) {
        throw e;
      }
      return EMPTY;
    }
  }
};

// src/ConsistentAttachmentsAndLinksPluginSettingsTab.ts
var import_obsidian5 = require("obsidian");
var ConsistentAttachmentsAndLinksPluginSettingsTab = class extends import_obsidian5.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Consistent attachments and links - Settings" });
    const settings = this.plugin.settings;
    new import_obsidian5.Setting(containerEl).setName("Move Attachments with Note").setDesc("Automatically move attachments when a note is relocated. This includes attachments located in the same folder or any of its subfolders.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.moveAttachmentsWithNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.moveAttachmentsWithNote));
    new import_obsidian5.Setting(containerEl).setName("Delete Unused Attachments with Note").setDesc("Automatically remove attachments that are no longer referenced in other notes when the note is deleted.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteAttachmentsWithNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteAttachmentsWithNote));
    new import_obsidian5.Setting(containerEl).setName("Update Links").setDesc("Automatically update links to attachments and other notes when moving notes or attachments.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.updateLinks = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.updateLinks));
    new import_obsidian5.Setting(containerEl).setName("Delete Empty Folders").setDesc("Automatically remove empty folders after moving notes with attachments.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteEmptyFolders = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteEmptyFolders));
    new import_obsidian5.Setting(containerEl).setName("Delete Duplicate Attachments on Note Move").setDesc("Automatically delete attachments when moving a note if a file with the same name exists in the destination folder. If disabled, the file will be renamed and moved.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteExistFilesWhenMoveNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteExistFilesWhenMoveNote));
    new import_obsidian5.Setting(containerEl).setName("Update Backlink Text on Note Rename").setDesc("When a note is renamed, its linked references are automatically updated. If this option is enabled, the text of backlinks to this note will also be modified.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.changeNoteBacklinksAlt = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.changeNoteBacklinksAlt));
    new import_obsidian5.Setting(containerEl).setName("Ignore Folders").setDesc("Specify a list of folders to ignore. Enter each folder on a new line.").addTextArea((cb) => cb.setPlaceholder("Example: .git, .obsidian").setValue(settings.ignoreFolders.join("\n")).onChange(async (value) => {
      const paths = value.trim().split("\n").map((value2) => this.getNormalizedPath(value2) + "/");
      settings.ignoreFolders = paths;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian5.Setting(containerEl).setName("Ignore Files").setDesc("Specify a list of files to ignore. Enter each file on a new line.").addTextArea((cb) => cb.setPlaceholder("Example: consistent-report.md").setValue(settings.ignoreFiles.join("\n")).onChange(async (value) => {
      const paths = value.trim().split("\n");
      settings.ignoreFiles = paths;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian5.Setting(containerEl).setName("Attachment Subfolder").setDesc('Specify the subfolder within the note folder to collect attachments into when using the "Collect All Attachments" hotkey. Leave empty to collect attachments directly into the note folder. You can use ${filename} as a placeholder for the current note name.').addText((cb) => cb.setPlaceholder("Example: _attachments").setValue(settings.attachmentsSubfolder).onChange(async (value) => {
      settings.attachmentsSubfolder = value;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian5.Setting(containerEl).setName("Consistency Report Filename").setDesc("Specify the name of the file for the consistency report.").addText((cb) => cb.setPlaceholder("Example: consistency-report.md").setValue(settings.consistencyReportFile).onChange(async (value) => {
      settings.consistencyReportFile = value;
      await this.plugin.saveSettings(settings);
    }));
  }
  getNormalizedPath(path2) {
    return path2.length == 0 ? path2 : (0, import_obsidian5.normalizePath)(path2);
  }
};

// src/ConsistentAttachmentsAndLinksPluginSettings.ts
var ConsistentAttachmentsAndLinksPluginSettings = class _ConsistentAttachmentsAndLinksPluginSettings {
  moveAttachmentsWithNote = true;
  deleteAttachmentsWithNote = true;
  updateLinks = true;
  deleteEmptyFolders = true;
  deleteExistFilesWhenMoveNote = true;
  changeNoteBacklinksAlt = false;
  ignoreFolders = [".git/", ".obsidian/"];
  ignoreFiles = ["consistency\\-report\\.md"];
  attachmentsSubfolder = "";
  consistencyReportFile = "consistency-report.md";
  getIgnoreFilesRegex() {
    return this.ignoreFiles.map((file) => RegExp(file));
  }
  static load(data) {
    return _ConsistentAttachmentsAndLinksPluginSettings.clone(data);
  }
  static clone(settings) {
    const target = new _ConsistentAttachmentsAndLinksPluginSettings();
    if (settings) {
      for (const key of Object.keys(target)) {
        if (key in settings && typeof settings[key] === typeof target[key]) {
          Object.assign(target, { [key]: settings[key] });
        }
      }
    }
    return target;
  }
};

// src/ConsistentAttachmentsAndLinksPlugin.ts
var import_posix3 = require("node:path/posix");
var ConsistentAttachmentsAndLinksPlugin = class extends import_obsidian6.Plugin {
  _settings;
  lh;
  fh;
  recentlyRenamedFiles = [];
  currentlyRenamingFiles = [];
  timerId;
  renamingIsActive = false;
  deletedNoteCache = /* @__PURE__ */ new Map();
  get settings() {
    return ConsistentAttachmentsAndLinksPluginSettings.clone(this._settings);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ConsistentAttachmentsAndLinksPluginSettingsTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("deleted", (file, prevCache) => this.handleDeletedMetadata(file, prevCache))
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => convertToSync(this.handleDeletedFile(file)))
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => this.handleRenamedFile(file, oldPath))
    );
    this.addCommand({
      id: "collect-all-attachments",
      name: "Collect All Attachments",
      callback: () => this.collectAllAttachments()
    });
    this.addCommand({
      id: "collect-attachments-current-note",
      name: "Collect Attachments in Current Note",
      checkCallback: this.collectAttachmentsCurrentNote.bind(this)
    });
    this.addCommand({
      id: "delete-empty-folders",
      name: "Delete Empty Folders",
      callback: () => this.deleteEmptyFolders()
    });
    this.addCommand({
      id: "convert-all-link-paths-to-relative",
      name: "Convert All Link Paths to Relative",
      callback: () => this.convertAllLinkPathsToRelative()
    });
    this.addCommand({
      id: "convert-all-embed-paths-to-relative",
      name: "Convert All Embed Paths to Relative",
      callback: () => this.convertAllEmbedsPathsToRelative()
    });
    this.addCommand({
      id: "replace-all-wikilinks-with-markdown-links",
      name: "Replace All Wiki Links with Markdown Links",
      callback: () => this.replaceAllWikilinksWithMarkdownLinks()
    });
    this.addCommand({
      id: "reorganize-vault",
      name: "Reorganize Vault",
      callback: () => this.reorganizeVault()
    });
    this.addCommand({
      id: "check-consistency",
      name: "Check Vault consistency",
      callback: () => this.checkConsistency()
    });
    this.lh = new LinksHandler(
      this.app,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
    this.fh = new FilesHandler(
      this.app,
      this.lh,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
  }
  isPathIgnored(path2) {
    if (path2.startsWith("./")) {
      path2 = path2.substring(2);
    }
    for (const folder of this._settings.ignoreFolders) {
      if (path2.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this._settings.getIgnoreFilesRegex()) {
      if (fileRegex.test(path2)) {
        return true;
      }
    }
    return false;
  }
  handleDeletedMetadata(file, prevCache) {
    if (!prevCache || !this._settings.deleteAttachmentsWithNote || this.isPathIgnored(file.path) || file.extension.toLowerCase() !== "md") {
      return;
    }
    this.deletedNoteCache.set(file.path, prevCache);
  }
  async handleDeletedFile(file) {
    if (this.isPathIgnored(file.path)) {
      return;
    }
    await this.saveAllOpenNotes();
    const fileExt = file.path.substring(file.path.lastIndexOf("."));
    if (fileExt == ".md") {
      if (this._settings.deleteAttachmentsWithNote) {
        const cache = this.deletedNoteCache.get(file.path);
        if (!cache) {
          await sleep(100);
          await this.handleDeletedFile(file);
          return;
        }
        this.deletedNoteCache.delete(file.path);
        await this.fh.deleteUnusedAttachmentsForCachedNote(file.path, cache, this._settings.deleteEmptyFolders);
      }
      if (this._settings.deleteEmptyFolders) {
        const list = await this.fh.safeList((0, import_posix3.dirname)(file.path));
        for (const folder of list.folders) {
          await this.fh.deleteEmptyFolders(folder);
        }
      }
    }
  }
  handleRenamedFile(file, oldPath) {
    this.recentlyRenamedFiles.push({ oldPath, newPath: file.path });
    clearTimeout(this.timerId);
    this.timerId = setTimeout(() => {
      convertToSync(this.HandleRecentlyRenamedFiles());
    }, 3e3);
  }
  async HandleRecentlyRenamedFiles() {
    if (!this.recentlyRenamedFiles || this.recentlyRenamedFiles.length == 0) {
      return;
    }
    if (this.renamingIsActive) {
      return;
    }
    this.renamingIsActive = true;
    this.currentlyRenamingFiles = this.recentlyRenamedFiles;
    this.recentlyRenamedFiles = [];
    await this.saveAllOpenNotes();
    new import_obsidian6.Notice("Fixing consistency for " + this.currentlyRenamingFiles.length + " renamed files...");
    console.log("Consistent Attachments and Links:\nFixing consistency for " + this.currentlyRenamingFiles.length + " renamed files...");
    try {
      for (const file of this.currentlyRenamingFiles) {
        if (this.isPathIgnored(file.newPath) || this.isPathIgnored(file.oldPath)) {
          return;
        }
        let result = null;
        const fileExt = file.oldPath.substring(file.oldPath.lastIndexOf("."));
        if (fileExt == ".md") {
          if ((0, import_posix3.dirname)(file.oldPath) != (0, import_posix3.dirname)(file.newPath) || this._settings.attachmentsSubfolder.contains("${filename}")) {
            if (this._settings.moveAttachmentsWithNote) {
              result = await this.fh.moveCachedNoteAttachments(
                file.oldPath,
                file.newPath,
                this._settings.deleteExistFilesWhenMoveNote,
                this._settings.attachmentsSubfolder,
                this._settings.deleteEmptyFolders
              );
              if (this._settings.updateLinks && result) {
                const changedFiles = result.renamedFiles.concat(result.movedAttachments);
                if (changedFiles.length > 0) {
                  await this.lh.updateChangedPathsInNote(file.newPath, changedFiles);
                }
              }
            }
            if (this._settings.updateLinks) {
              await this.lh.updateInternalLinksInMovedNote(file.oldPath, file.newPath);
            }
            if (this._settings.deleteEmptyFolders) {
              const list = await this.fh.safeList((0, import_posix3.dirname)(file.oldPath));
              for (const folder of list.folders) {
                await this.fh.deleteEmptyFolders(folder);
              }
            }
          }
        }
        const updateAlts = this._settings.changeNoteBacklinksAlt && fileExt == ".md";
        if (this._settings.updateLinks) {
          await this.lh.updateLinksToRenamedFile(file.oldPath, file.newPath, updateAlts);
        }
        if (result && result.movedAttachments && result.movedAttachments.length > 0) {
          new import_obsidian6.Notice("Moved " + result.movedAttachments.length + " attachment" + (result.movedAttachments.length > 1 ? "s" : ""));
        }
      }
    } catch (e) {
      showError(e);
    }
    new import_obsidian6.Notice("Fixing Consistency Complete");
    console.log("Consistent Attachments and Links:\nFixing consistency complete");
    this.renamingIsActive = false;
    if (this.recentlyRenamedFiles && this.recentlyRenamedFiles.length > 0) {
      clearTimeout(this.timerId);
      this.timerId = setTimeout(() => {
        convertToSync(this.HandleRecentlyRenamedFiles());
      }, 500);
    }
  }
  collectAttachmentsCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.collectAttachments(note));
    }
    return true;
  }
  async collectAttachments(note) {
    if (this.isPathIgnored(note.path)) {
      new import_obsidian6.Notice("Note path is ignored");
      return;
    }
    await this.saveAllOpenNotes();
    const result = await this.fh.collectAttachmentsForCachedNote(
      note.path,
      this._settings.attachmentsSubfolder,
      this._settings.deleteExistFilesWhenMoveNote,
      this._settings.deleteEmptyFolders
    );
    if (result && result.movedAttachments && result.movedAttachments.length > 0) {
      await this.lh.updateChangedPathsInNote(note.path, result.movedAttachments);
    }
    if (result.movedAttachments.length == 0) {
      new import_obsidian6.Notice("No files found that need to be moved");
    } else {
      new import_obsidian6.Notice("Moved " + result.movedAttachments.length + " attachment" + (result.movedAttachments.length > 1 ? "s" : ""));
    }
  }
  async collectAllAttachments() {
    let movedAttachmentsCount = 0;
    let processedNotesCount = 0;
    await this.saveAllOpenNotes();
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian6.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Collecting attachments # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.fh.collectAttachmentsForCachedNote(
        note.path,
        this._settings.attachmentsSubfolder,
        this._settings.deleteExistFilesWhenMoveNote,
        this._settings.deleteEmptyFolders
      );
      if (result && result.movedAttachments && result.movedAttachments.length > 0) {
        await this.lh.updateChangedPathsInNote(note.path, result.movedAttachments);
        movedAttachmentsCount += result.movedAttachments.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (movedAttachmentsCount == 0) {
      new import_obsidian6.Notice("No files found that need to be moved");
    } else {
      new import_obsidian6.Notice("Moved " + movedAttachmentsCount + " attachment" + (movedAttachmentsCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async convertAllEmbedsPathsToRelative() {
    await this.saveAllOpenNotes();
    let changedEmbedCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian6.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Converting embed paths to relative # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.convertAllNoteEmbedsPathsToRelative(note.path);
      if (result && result.length > 0) {
        changedEmbedCount += result.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (changedEmbedCount == 0) {
      new import_obsidian6.Notice("No embeds found that need to be converted");
    } else {
      new import_obsidian6.Notice("Converted " + changedEmbedCount + " embed" + (changedEmbedCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async convertAllLinkPathsToRelative() {
    await this.saveAllOpenNotes();
    let changedLinksCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian6.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Converting link paths to relative # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.convertAllNoteLinksPathsToRelative(note.path);
      if (result && result.length > 0) {
        changedLinksCount += result.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (changedLinksCount == 0) {
      new import_obsidian6.Notice("No links found that need to be converted");
    } else {
      new import_obsidian6.Notice("Converted " + changedLinksCount + " link" + (changedLinksCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async replaceAllWikilinksWithMarkdownLinks() {
    await this.saveAllOpenNotes();
    let changedLinksCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian6.Notice("", 0);
    for (const note of notes) {
      i++;
      const message = `Replacing wikilinks with markdown links # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.replaceAllNoteWikilinksWithMarkdownLinks(note.path);
      if (result && (result.links.length > 0 || result.embeds.length > 0)) {
        changedLinksCount += result.links.length;
        changedLinksCount += result.embeds.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (changedLinksCount == 0) {
      new import_obsidian6.Notice("No wiki links found that need to be replaced");
    } else {
      new import_obsidian6.Notice("Replaced " + changedLinksCount + " wikilink" + (changedLinksCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async deleteEmptyFolders() {
    await this.fh.deleteEmptyFolders("/");
  }
  async checkConsistency() {
    await this.saveAllOpenNotes();
    const badLinks = new ConsistencyCheckResult("Bad links");
    const badEmbeds = new ConsistencyCheckResult("Bad embeds");
    const wikiLinks = new ConsistencyCheckResult("Wiki links");
    const wikiEmbeds = new ConsistencyCheckResult("Wiki embeds");
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian6.Notice("", 0);
    for (const note2 of notes) {
      i++;
      const message = `Checking note # ${i} / ${notes.length} - ${note2.path}`;
      notice.setMessage(message);
      console.debug(message);
      await this.lh.checkConsistency(note2, badLinks, badEmbeds, wikiLinks, wikiEmbeds);
    }
    notice.hide();
    const text = badLinks.toString() + badEmbeds.toString() + wikiLinks.toString() + wikiEmbeds.toString();
    const notePath = this._settings.consistencyReportFile;
    const note = this.app.vault.getFileByPath(notePath) ?? await this.app.vault.create(notePath, "");
    await this.app.vault.modify(note, text);
    let fileOpened = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.getDisplayText() != "" && notePath.startsWith(leaf.getDisplayText())) {
        fileOpened = true;
      }
    });
    if (!fileOpened) {
      await this.app.workspace.openLinkText(notePath, "/", false);
    }
  }
  async reorganizeVault() {
    await this.saveAllOpenNotes();
    await this.replaceAllWikilinksWithMarkdownLinks();
    await this.convertAllEmbedsPathsToRelative();
    await this.convertAllLinkPathsToRelative();
    await this.collectAllAttachments();
    await this.deleteEmptyFolders();
    new import_obsidian6.Notice("Reorganization of the vault completed");
  }
  async loadSettings() {
    this._settings = ConsistentAttachmentsAndLinksPluginSettings.load(await this.loadData());
  }
  async saveSettings(newSettings) {
    this._settings = ConsistentAttachmentsAndLinksPluginSettings.clone(newSettings);
    await this.saveData(this._settings);
    this.lh = new LinksHandler(
      this.app,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
    this.fh = new FilesHandler(
      this.app,
      this.lh,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
  }
  async saveAllOpenNotes() {
    for (const leaf of this.app.workspace.getLeavesOfType("markdown")) {
      const view = leaf.view;
      await view.save();
    }
  }
};
//!!! link.displayText is always "" - OBSIDIAN BUG?, so get display text manually
